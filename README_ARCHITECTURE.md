# Сравнение архитектур: Модульный монолит, SOA и Микросервисы

В данном документе приведено детальное сравнение трех архитектурных подходов, их сходства, различия, а также плюсы и минусы на примере проекта Travelhoop.

## Сравнительная таблица

| Характеристика | Модульный монолит | SOA (Service-Oriented Architecture) | Микросервисы |
| :--- | :--- | :--- | :--- |
| **Деплой (Развертывание)** | **Единый юнит**. Все модули деплоятся одновременно как одно приложение. | **Множественный**. Каждый сервис деплоится независимо. | **Независимый**. Каждый сервис максимально автономен и мал. |
| **Запуск (Runtime)** | **Один процесс** в ОС (например, один процесс Node.js). | **Множество процессов**. Часто разные технологии и сервера. | **Множество контейнеров**. Каждый сервис живет в своем контейнере. |
| **База данных** | **Общая БД**. Модули имеют свои таблицы, но живут в одной базе. | **Часто общая БД** или общие корпоративные хранилища данных. | **У каждого своя БД**. Прямой доступ к чужой базе строго запрещен. |
| **Связь (Communication)** | **Внутрипроцессная** (вызовы функций) или внутренняя шина событий (Redis локально). | **Сетевая (через ESB)**. Используется тяжелая шина (Enterprise Service Bus). | **Сетевая (облегченная)**. HTTP/gRPC или легкие брокеры (RabbitMQ/Redis). |
| **Управление данными** | ACID транзакции легко доступны (одна база). | Распределенные транзакции (сложно и медленно). | **Eventual Consistency**. Согласованность через события в конечном итоге. |
| **Команда разработки** | Одна большая команда или несколько, работающих в одном моно-репозитории. | Разные команды, часто использующие разные языки программирования. | **Two-pizza teams**. Каждая команда полностью владеет своим сервисом. |
| **Инфраструктура** | Простая: один сервер, одна база, один CI/CD пайплайн. | Очень сложная: требуется управление ESB, реестрами сервисов. | Высокая: нужен Kubernetes, Service Mesh, мониторинг. |

---

## Подробный разбор отличий

### 1. Единый процесс vs Распределенная система
*   **SOA:** Каждый сервис — это отдельное приложение. Общение идет по сети. Это требует настройки Service Discovery и балансировщиков.
*   **Микросервисы:** Аналогично SOA, но сервисы мельче и независимее.
*   **Наш проект (Модульный монолит):** Все модули (`booking`, `couch`, `user`) работают внутри **одного процесса** NodeJS. Это исключает сетевые задержки и упрощает отладку.

### 2. Подход к базе данных и транзакциям
*   **В модульном монолите (Travelhoop):** У нас одна физическая база данных. Мы можем использовать классические транзакции (ACID) между таблицами разных модулей, что гарантирует надежность данных.
*   **В SOA:** Исторически часто использовалась одна БД, разделенная на схемы, из-за дороговизны лицензий (Oracle/DB2). Но логически сервисы пытались быть независимыми, что вело к сложным двухфазным коммитам (2PC).
*   **В микросервисах:** У каждого своя БД. Если нужно обновить данные в двух сервисах, используется паттерн **Saga** или **Eventual Consistency**.

### 3. Шина данных
*   **SOA:** Использует Enterprise Service Bus (ESB) — "умную" шину с логикой трансформации и маршрутизации.
*   **Наш проект:** Использует Redis как "глухую трубу" (dumb pipe). Он просто передает сообщения, а вся бизнес-логика сосредоточена внутри модулей.

---

## Плюсы и минусы

### Модульный монолит
*   **Плюсы:** Простота деплоя, высокая производительность (нет сети), строгая типизация между модулями, легкость рефакторинга.
*   **Минусы:** Нельзя масштабировать модули по отдельности, одна ошибка может уронить всё приложение, время сборки растет с ростом проекта.

### SOA
*   **Плюсы:** Возможность интеграции разнородных систем (legacy), повторное использование сервисов в масштабах корпорации.
*   **Минусы:** Огромная сложность внедрения и поддержки, "бутылочное горлышко" в виде ESB.

### Микросервисы
*   **Плюсы:** Независимое масштабирование, независимый деплой, свобода выбора технологий для каждого сервиса.
*   **Минусы:** Сложность управления (Kubernetes, логи, трассировка), проблемы с консистентностью данных, сетевые накладные расходы.

---

## Почему наш проект — это именно Модульный монолит?

1.  **Единый запуск:** В файле `src/app/travelhoop/src/app.ts` все модули инициализируются одновременно:
    ```typescript
    modules.forEach(m => m.use(app, { dbConnection, redis }));
    ```
2.  **Общая база:** Мы передаем одно и то же соединение `dbConnection` во все модули.
3.  **Логические границы:** Модули разделены не физически (разными серверами), а на уровне кода и папок в `src/modules`. Это позволяет получить порядок в архитектуре, сохраняя простоту монолита.
